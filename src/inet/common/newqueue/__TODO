DONE priorityClassifier for multiple servers
DONE PacketQueue parameter for drop or canPush behaviour

!add signals and statistics to all packet queue modules!
!understand diffserv queueing elements and make them work with the new API!

the following components could use subclassing
Multiplexer = Classifier
Demultiplexer = Scheduler
Delayer = Server
Provider = Producer = Source
Collector = Consumer = Sink
Router = Demultiplexer + Classifier
Network = Router + Delayer + Router

review and add tests for: OrdinalBasedDropper, OrdinalBasedDuplicator, ThresholdDropper, RedDropper
should ThresholdDropper replace PacketBuffer?

Add passive/active labels to gates?
DONE Extend API with gate parameters where applicable

Meter wtf? coloring (ColorTag or MarkTag), lehetne olyan classifier/scheduler ami coloring alapjan megy
Marker, MarkerClassifier, MarkerScheduler, etc.

DONE Valto (Scheduler, Classifier) transition matrix (probability, stay time)

DONE classifierFunction, classifierClass -> C++ macro

PacketServer-nek kell olyan parametere legyen, ami azt befolyasolja, hogy mikor servelhet, pl: csak kedden vagy amikor van token a bucket-ben


questions:
 - should we support asynchronous external behaviour?
   DONE = keep this
 - should we support asynchronous internal behaviour?
   DONE = drop this feature
 - do we need this level of detail for the number of contract interfaces or use more functions in less interfaces?
   DONE = use several interfaces one for each kind of input and one for each kind of output
 - where module subtyping can be replaced with parameterization, should we do it?
   = we should, but we should also have the subtypes with the parameters set

components:
 queue, classifier, scheduler, filter, duplicator, delayer, server, source, sink, etc.

pushed
popped
dropped
generated
available

queue: storage order, drop strategy, pop strategy

notification pop available
notification push available
push/pop duality

canPushPacket -> pushPacket
canPopPacket -> popPacket

pushed (enqueued) - dropped - popped (dequeued) + generated = queue length = poppable (available) + delayed


stop with an error during initialize if the connected components are not compatible (i.e. they won't work)

input:
 - push, pop -> absorber (push)
 - push, no pop -> consumer (push)
 - no push, pop -> collector ()

output:
 - push, pop -> emitter (pop, request)
 - push, no pop -> producer ()
 - no push, pop -> provider (pop, request)

emitter -> absorber, consumer
producer -> absorber, consumer
provider -> absorber, collector

emitter, provider -> absorber
emitter, producer -> consumer
emitter, provider -> collector

queue (consumer, provider): (empty, getNum, get, remove)
 - input: push, no pop
 - output: no push, pop
 - can be asynchronous

classifier (consumer, producer):
 - input: push, no pop
 - output: push, no pop
 - can be asynchronous

scheduler (collector, provider):
 - input: no push, pop
 - output: no push, pop
 - can be asynchronous
 
filter (absorber, emitter):
 - input: push, pop
 - output: push, pop
 - can be asynchronous

duplicator (consumer, producer):
 - input: push, no pop
 - output: push, no pop
 - can be asynchronous

delayer (consumer, producer):
 - input: push, no pop
 - output: push, no pop
 - always asynchronous

processor:
 - input: no push, pop
 - output: push, no pop
 - alwyas asynchronous

channel ez nem a queue veletlenul?: olyasmi amibe pusholni lehet, de nem mindig csak amikor epp nem foglalt
 - input: push, no pop
 - output: no push, pop
 
leaky bucket/token bucket (= queue + server):
 - input: no push, pop
 - output: push, no pop
 - always asynchronous
 
source -> producer, provider: TODO

sink -> consumer, collector: TODO

multiplexer: one input to several output: cannot implement collection API
 - input: no push, pop
 - output: no push, pop

demultiplexer: several input to one output: cannot implement collection API
 - input: push, no pop
 - output: push, no pop




 - port these old components: Delay, Join, Dropper, Duplicator


The queue API should simulatenously support the following:

different external structure:
 - queues as submodules without being connected to the outside world via gates
   the queue is not in the packet path, it's rather part of the processing module
 - queues which are connected to generators and consumers
   the queue is in the packet path

different modes of operation:
 - queues must be able to operate synchronously without utilizing handleMessage
   a packet getting into a queue may immediately cause another packet to get out from the queue
 - queues must be able to operate asynchronously with utilizing handleMessage
   this is the old INET 4.0 behaviour

abstraction via composition:
 - queues can be simple modules
 - queues can be composed from simple modules into compound queue modules

easy access:
 - protocols should be able to use queues without knowing what is the queue's
   module structure, mode of operation, simple or compound, etc.

IPacketQueue
PacketQueueBase
TailDropQueue
Prioritizer -> PriorityQueue
InfiniteQueue/FifoQueue
InfiniteStack/LifoQueue
CompoundQueue

Join/Fork/Delay

output gate:
 - connected or free
 - synchronous or asynchronous
 - push or pull

input gate:
 - connected or free

what can be connected to where exactly? it's not clear what is possible with composition!

what doesn't work, for example:
 - Queue -> Queue getNumPackets()? popPacket()? requestPacket()?
 - Queue -> Sink no requestPacket()?
 - Queue -> Delayer ???
 - SchedulerBase overrides WrrScheduler behavior in pop()

primitive modules:
 - infinite queue (1 in gate, 1 out gate)
 - limited queue (1 in gate, 1 out gate, capacity parameter)
 - packet classifier (1 in gate, N out gate, classifier function parameter)
 - priority queue (N in gate, 1 out gate, priority function parameter)
 - wrr scheduler 
 - delay (1 in gate, 1 out gate, delay parameter)
   when pushPacket() is called, it calls pushPacket() on out after delay
   when requestPacket() is called, it calls requestPacket() on in gate
 - drop (1 in gate, 1 out gate, drop predicate parameter)
   when pushPacket() is called, it calls pushPacket() on out gate if drop predicate returns false
   when requestPacket() is called, it calls requestPacket() on in gate
 - source (1 out gate, interval parameter, packet generator function parameter)
   calls pushPacket() on out gate periodically with a newly generated packet
 - sink (1 in gate)
   calls requestPacket() on in gate initially and every time it receives a packet
   when pushPacket() is called, it deletes the packet

question: does it make sense to connect any out gate to any in gate? if not, then what are the constraints?

operations:
 - getNumPackets(): returns the number of packets of what exactly?
 - pushPacket()
 - popPacket()
 - requestPacket()
